<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fuzzy Match CLI</title>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: 'Source Code Pro', 'Courier New', monospace;
      background-color: #f7f7f7;
      color: #000000;
      padding: 20px;
      min-height: 100vh;
    }

    #container {
      max-width: 1000px;
      margin: 0 auto;
    }

    #logo {
      display: block;
      margin: 0 auto 10px;
      max-width: 200px;
    }
    
    #console {
      background-color: #ffffff;
      border: 1px solid #cccccc;
      border-radius: 5px;
      padding: 15px;
      height: 400px;
      overflow-y: auto;
      margin-bottom: 20px;
      white-space: pre-wrap;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    
    .prompt {
      color: #F14C32;
      font-weight: bold;
    }
    
    .command {
      color: #000000;
    }
    
    .error {
      color: #F14C32;
    }

    .success {
      color: #4CAF50;
    }

    .info {
      color: #000000;
    }
    
    input[type="text"] {
      background-color: #ffffff;
      border: 1px solid #cccccc;
      color: #000000;
      padding: 8px;
      width: 80%;
      font-family: 'Source Code Pro', monospace;
      font-size: 16px;
      border-radius: 4px;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    button {
      background-color: #333333;
      border: 1px solid #444;
      color: #FAFAFA;
      padding: 8px 15px;
      cursor: pointer;
      transition: background-color 0.2s, box-shadow 0.2s;
      font-family: 'Source Code Pro', monospace;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    button:hover {
      background-color: #3a3a3a;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }
    
    #executeButton {
      background-color: #F14C32;
      border: 1px solid #F3705B;
      padding: 12px 25px;
      font-size: 18px;
      margin-bottom: 20px;
      border-radius: 4px;
      box-shadow: 0 0 8px rgba(241, 76, 50, 0.6);
    }

    #executeButton:hover {
      background-color: #F3705B;
      box-shadow: 0 0 12px rgba(241, 76, 50, 0.8);
    }

    #clearButton {
      background-color: #231F20;
      border: 1px solid #F14C32;
      margin-left: 10px;
      color: #FAFAFA;
    }

    #clearButton:hover {
      background-color: #333333;
    }

    .button-row {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
    }
    
    .file-input {
      display: none;
    }
    
    .file-label {
      display: inline-block;
      background-color: #333333;
      border: 1px solid #444;
      color: #FAFAFA;
      padding: 8px 15px;
      cursor: pointer;
      transition: background-color 0.2s;
      margin-right: 10px;
    }
    
    .file-label:hover {
      background-color: #444444;
    }

    .file-name {
      font-style: italic;
      margin-right: 10px;
    }

    #fileInputs {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 20px;
    }

    .file-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .data-select {
      background-color: #ffffff;
      border: 1px solid #cccccc;
      color: #000000;
      padding: 8px;
      margin-top: 10px;
      font-family: 'Source Code Pro', monospace;
      border-radius: 4px;
    }

    #returnColumnsContainer label {
      display: block;
      margin-top: 5px;
    }

    #returnColumnsContainer {
      margin-top: 10px;
    }

    .control-group {
      margin-top: 20px;
    }

    #thresholdContainer label {
      margin-right: 10px;
    }

    #thresholdRange {
      vertical-align: middle;
      margin-left: 5px;
    }

    #thresholdValue {
      font-weight: bold;
      margin-left: 5px;
    }

    #outputTypeContainer label {
      margin-right: 15px;
    }

    #inputArea {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }

    #inputArea {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    #progressBar {
      width: 100%;
      background-color: #333333;
      border-radius: 5px;
      margin-top: 20px;
      display: none;
      box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    }

    #progressBarFill {
      height: 20px;
      background: linear-gradient(90deg, #F14C32, #F3705B);
      border-radius: 5px;
      width: 0%;
      transition: width 0.3s;
    }

    .result-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
    }

    .result-table th, 
    .result-table td {
      border: 1px solid #444;
      padding: 8px;
      text-align: left;
    }

    .result-table th {
      background-color: #2a2a2a;
    }

    .score-high {
      background-color: rgba(241, 76, 50, 0.2);
    }

    .score-medium {
      background-color: rgba(241, 76, 50, 0.15);
    }

    .score-low {
      background-color: rgba(241, 76, 50, 0.1);
    }
    
    .download-btn {
      background-color: #F14C32;
      padding: 10px 15px;
      margin: 10px 0;
      cursor: pointer;
      color: #FAFAFA;
    }

    .fallback-btn {
      background-color: #333333;
      padding: 10px 15px;
      margin: 10px 5px;
      cursor: pointer;
      color: #FAFAFA;
    }

    h1 {
      text-align: center;
      color: #F14C32;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div id="container">
    <img src="FINAL_LOGO_PSI.svg" alt="PSI Logo" id="logo" />
    <h1>Fuzzy Match CLI Tool</h1>
    <div class="button-row">
      <button id="executeButton">Execute Fuzzy Match</button>
      <button id="clearButton">Clear Console</button>
    </div>
  
  <div id="console">
    <div class="info">*** Fuzzy Match CLI Tool ***</div>
    <div class="info">Click 'Execute Fuzzy Match' to begin</div>
  </div>
  
  <div id="inputArea">
    <input type="text" id="commandInput" placeholder="Type your response here..." disabled>
    <button id="submitButton" disabled>Submit</button>
  </div>
  
  <div id="progressBar" role="progressbar" aria-live="polite" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
    <div id="progressBarFill"></div>
  </div>

  <div id="fileInputs">
    <div class="file-group">
      <label for="primaryFileInput" id="primaryFileLabel" class="file-label">Select Primary File</label>
      <span id="primaryFileName" class="file-name">No file chosen</span>
      <input type="file" id="primaryFileInput" class="file-input" accept=".csv,.xlsx,.xls">
    </div>
    <div class="file-group">
      <label for="secondaryFileInput" id="secondaryFileLabel" class="file-label">Select Secondary File</label>
      <span id="secondaryFileName" class="file-name">No file chosen</span>
      <input type="file" id="secondaryFileInput" class="file-input" accept=".csv,.xlsx,.xls">
    </div>
  </div>

  <div id="dataSelectors">
    <select id="primarySheetSelect" class="data-select" style="display:none"></select>
    <select id="secondarySheetSelect" class="data-select" style="display:none"></select>
    <select id="primaryColumnSelect" class="data-select" style="display:none"></select>
    <select id="secondaryColumnSelect" class="data-select" style="display:none"></select>
    <div id="returnColumnsContainer" style="display:none"></div>
    <div id="thresholdContainer" style="display:none" class="control-group">
      <label for="thresholdRange">Similarity Threshold:
        <span id="thresholdValue">0.70</span>
      </label>
      <input type="range" id="thresholdRange" min="0" max="1" step="0.01" value="0.70">
      <button id="thresholdConfirmBtn" class="download-btn" style="margin-left:10px;">Confirm</button>
    </div>
  <div id="outputTypeContainer" style="display:none" class="control-group">
      <label><input type="radio" name="outputType" value="display" checked> Display</label>
      <label><input type="radio" name="outputType" value="csv"> CSV</label>
      <label><input type="radio" name="outputType" value="excel"> Excel</label>
      <button id="outputTypeConfirmBtn" class="download-btn" style="margin-left:10px;">Confirm</button>
    </div>
    <div id="resultsContainer"></div>
  </div>

  </div> <!-- end container -->

  <script>
    // Main variables
    const console = document.getElementById('console');
    const commandInput = document.getElementById('commandInput');
    const submitButton = document.getElementById('submitButton');
    const executeButton = document.getElementById('executeButton');
    const clearButton = document.getElementById('clearButton');
    const primaryFileInput = document.getElementById('primaryFileInput');
    const secondaryFileInput = document.getElementById('secondaryFileInput');
    const primaryFileName = document.getElementById('primaryFileName');
    const secondaryFileName = document.getElementById('secondaryFileName');
    const progressBar = document.getElementById('progressBar');
    const progressBarFill = document.getElementById('progressBarFill');
    const primarySheetSelect = document.getElementById('primarySheetSelect');
    const secondarySheetSelect = document.getElementById('secondarySheetSelect');
    const primaryColumnSelect = document.getElementById('primaryColumnSelect');
    const secondaryColumnSelect = document.getElementById('secondaryColumnSelect');
    const returnColumnsContainer = document.getElementById('returnColumnsContainer');
    const thresholdContainer = document.getElementById('thresholdContainer');
    const thresholdRange = document.getElementById('thresholdRange');
    const thresholdValue = document.getElementById('thresholdValue');
    const thresholdConfirmBtn = document.getElementById('thresholdConfirmBtn');
    const outputTypeContainer = document.getElementById('outputTypeContainer');
    const outputTypeConfirmBtn = document.getElementById('outputTypeConfirmBtn');
    const resultsContainer = document.getElementById('resultsContainer');

    // State variables
    let state = {
      workflow: null,
      step: 0,
      primaryFile: null,
      secondaryFile: null,
      primaryData: null,
      secondaryData: null,
      primarySheetNames: null,
      secondarySheetNames: null,
      primarySelectedSheet: null,
      secondarySelectedSheet: null,
      primaryColumn: null,
      secondaryColumn: null,
      returnColumns: [],
      threshold: 0.7,
      matchResults: [],
      outputType: null
    };

    // Workflows
    const workflows = {
      fuzzyMatch: [
        { 
          prompt: "Would you like to match data between two files (1) or find duplicates in a single file (2)?",
          process: function(response) {
            if (response === "1") {
              state.matchType = "twoFiles";
              writeToConsole("You selected: Match between two files", "info");
              return true;
            } else if (response === "2") {
              state.matchType = "singleFile";
              writeToConsole("You selected: Find duplicates in a single file", "info");
              return true;
            } else {
              writeToConsole("Please enter 1 or 2.", "error");
              return false;
            }
          }
        },
        // First file prompt and handler
        {
          prompt: "Please select the primary file (CSV or Excel)",
          process: function() {
            // Make sure the file input is reset first
            primaryFileInput.value = null;
            primaryFileName.textContent = "No file chosen";
            state.primaryFile = null;
            writeToConsole("Waiting for file selection...", "info");

            return new Promise((resolve) => {
              const fileChangeHandler = async function(e) {
                // Remove the event handler after it's called
                primaryFileInput.removeEventListener('change', fileChangeHandler);
                
                const file = e.target.files[0];
                if (!file) {
                  writeToConsole("No file selected or file selection cancelled.", "error");
                  resolve(false);
                  return;
                }

                state.primaryFile = file;
                primaryFileName.textContent = file.name;
                writeToConsole(`Selected file: ${file.name}`, "info");
                
                try {
                  const fileData = await readFile(file);
                  
                  // Check if this is an Excel file with multiple sheets
                  if (fileData.isExcel && fileData.sheetNames && fileData.sheetNames.length > 1) {
                    state.primarySheetNames = fileData.sheetNames;
                    
                    // If there are multiple sheets, we'll ask which one to use in the next step
                    writeToConsole(`Excel file has ${fileData.sheetNames.length} sheets: ${fileData.sheetNames.join(", ")}`, "info");
                    resolve(true);
                  } else {
                    // For CSV or Excel with only one sheet, we can proceed directly
                    if (fileData.data) {
                      state.primaryData = fileData.data;
                      if (state.primaryData && state.primaryData.length > 0) {
                        writeToConsole(`Successfully loaded ${state.primaryData.length} rows`, "success");
                        writeToConsole(`Columns: ${Object.keys(state.primaryData[0]).join(", ")}`, "info");
                      } else {
                        writeToConsole("File appears to be empty or invalid.", "error");
                        resolve(false);
                        return;
                      }
                    }
                    
                    // For single-sheet Excel files, remember the sheet name
                    if (fileData.isExcel) {
                      state.primarySheetNames = fileData.sheetNames;
                      state.primarySelectedSheet = fileData.currentSheet;
                    }
                    
                    resolve(true);
                  }
                } catch (error) {
                  writeToConsole(`Error reading file: ${error.message}`, "error");
                  resolve(false);
                }
              };
              
              // Add the event listener
              primaryFileInput.addEventListener('change', fileChangeHandler);
              
            });
          }
        },
        // Primary sheet selection (conditionally shown)
        {
          prompt: function() {
            if (state.primarySheetNames && state.primarySheetNames.length > 1 && !state.primaryData) {
              return `Select a sheet from the primary file:`;
            }
            return null; // Skip this step if not applicable
          },
          process: function() {
            return new Promise((resolve) => {
              if (!(state.primarySheetNames && state.primarySheetNames.length > 1 && !state.primaryData)) {
                resolve(true);
                return;
              }

              commandInput.disabled = true;
              submitButton.disabled = true;

              populateSelect(primarySheetSelect, state.primarySheetNames);
              showElement(primarySheetSelect);

              const handler = async function() {
                primarySheetSelect.removeEventListener('change', handler);
                hideElement(primarySheetSelect);

                const selectedSheet = primarySheetSelect.value;
                state.primarySelectedSheet = selectedSheet;
                writeToConsole(`You selected sheet: ${selectedSheet}`, 'info');

                try {
                  const fileData = await readFile(state.primaryFile, selectedSheet);
                  state.primaryData = fileData.data;

                  if (state.primaryData && state.primaryData.length > 0) {
                    writeToConsole(`Successfully loaded ${state.primaryData.length} rows from sheet "${selectedSheet}"`, 'success');
                    writeToConsole(`Columns: ${Object.keys(state.primaryData[0]).join(', ')}`, 'info');
                    resolve(true);
                  } else {
                    writeToConsole('Sheet appears to be empty or invalid.', 'error');
                    resolve(false);
                  }
                } catch (error) {
                  writeToConsole(`Error reading sheet: ${error.message}`, 'error');
                  resolve(false);
                }
              };

              primarySheetSelect.addEventListener('change', handler);
            });
          }
        },
        // Second file or column selection
        {
          prompt: function() {
            return state.matchType === "twoFiles" ? 
              "Please select the secondary file (CSV or Excel)" : 
              "Which column contains the text you want to check for duplicates?";
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              // Make sure the file input is reset first
              secondaryFileInput.value = null;
              secondaryFileName.textContent = "No file chosen";
              state.secondaryFile = null;
              writeToConsole("Waiting for file selection...", "info");

              return new Promise((resolve) => {
                const fileChangeHandler = async function(e) {
                  // Remove the event handler after it's called
                  secondaryFileInput.removeEventListener('change', fileChangeHandler);
                  
                  const file = e.target.files[0];
                  if (!file) {
                    writeToConsole("No file selected or file selection cancelled.", "error");
                    resolve(false);
                    return;
                  }
                  
                  state.secondaryFile = file;
                  secondaryFileName.textContent = file.name;
                  writeToConsole(`Selected file: ${file.name}`, "info");
                  
                  try {
                    const fileData = await readFile(file);
                    
                    // Check if this is an Excel file with multiple sheets
                    if (fileData.isExcel && fileData.sheetNames && fileData.sheetNames.length > 1) {
                      state.secondarySheetNames = fileData.sheetNames;
                      
                      // If there are multiple sheets, we'll ask which one to use in the next step
                      writeToConsole(`Excel file has ${fileData.sheetNames.length} sheets: ${fileData.sheetNames.join(", ")}`, "info");
                      resolve(true);
                    } else {
                      // For CSV or Excel with only one sheet, we can proceed directly
                      if (fileData.data) {
                        state.secondaryData = fileData.data;
                        if (state.secondaryData && state.secondaryData.length > 0) {
                          writeToConsole(`Successfully loaded ${state.secondaryData.length} rows`, "success");
                          writeToConsole(`Columns: ${Object.keys(state.secondaryData[0]).join(", ")}`, "info");
                        } else {
                          writeToConsole("File appears to be empty or invalid.", "error");
                          resolve(false);
                          return;
                        }
                      }
                      
                      // For single-sheet Excel files, remember the sheet name
                      if (fileData.isExcel) {
                        state.secondarySheetNames = fileData.sheetNames;
                        state.secondarySelectedSheet = fileData.currentSheet;
                      }
                      
                      resolve(true);
                    }
                  } catch (error) {
                    writeToConsole(`Error reading file: ${error.message}`, "error");
                    resolve(false);
                  }
                };
                
                // Add the event listener
                secondaryFileInput.addEventListener('change', fileChangeHandler);
                
              });
            } else {
              // Single file, select column via dropdown
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                const availableColumns = Object.keys(state.primaryData[0]);
                populateSelect(primaryColumnSelect, availableColumns);
                showElement(primaryColumnSelect);

                const handler = function() {
                  primaryColumnSelect.removeEventListener('change', handler);
                  hideElement(primaryColumnSelect);

                  const col = primaryColumnSelect.value;
                  state.primaryColumn = col;
                  writeToConsole(`You selected column: ${col}`, 'info');
                  state.secondaryData = state.primaryData;
                  state.secondaryColumn = state.primaryColumn;
                  resolve(true);
                };

                primaryColumnSelect.addEventListener('change', handler);
              });
            }
          }
        },
        // Secondary sheet selection (conditionally shown)
        {
          prompt: function() {
            if (state.matchType === "twoFiles" && state.secondarySheetNames && state.secondarySheetNames.length > 1 && !state.secondaryData) {
              return `Select a sheet from the secondary file:`;
            }
            return null; // Skip this step if not applicable
          },
          process: function() {
            return new Promise((resolve) => {
              if (!(state.matchType === 'twoFiles' && state.secondarySheetNames && state.secondarySheetNames.length > 1 && !state.secondaryData)) {
                resolve(true);
                return;
              }

              commandInput.disabled = true;
              submitButton.disabled = true;

              populateSelect(secondarySheetSelect, state.secondarySheetNames);
              showElement(secondarySheetSelect);

              const handler = async function() {
                secondarySheetSelect.removeEventListener('change', handler);
                hideElement(secondarySheetSelect);

                const selectedSheet = secondarySheetSelect.value;
                state.secondarySelectedSheet = selectedSheet;
                writeToConsole(`You selected sheet: ${selectedSheet}`, 'info');

                try {
                  const fileData = await readFile(state.secondaryFile, selectedSheet);
                  state.secondaryData = fileData.data;

                  if (state.secondaryData && state.secondaryData.length > 0) {
                    writeToConsole(`Successfully loaded ${state.secondaryData.length} rows from sheet "${selectedSheet}"`, 'success');
                    writeToConsole(`Columns: ${Object.keys(state.secondaryData[0]).join(', ')}`, 'info');
                    resolve(true);
                  } else {
                    writeToConsole('Sheet appears to be empty or invalid.', 'error');
                    resolve(false);
                  }
                } catch (error) {
                  writeToConsole(`Error reading sheet: ${error.message}`, 'error');
                  resolve(false);
                }
              };

              secondarySheetSelect.addEventListener('change', handler);
            });
          }
        },
        {
          prompt: function() {
            return state.matchType === "twoFiles" ?
              "Which column from the primary file should be used for matching?" :
              "What threshold would you like to use for similarity (0.0-1.0)? Higher values require closer matches (recommended: 0.7)";
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                const availableColumns = Object.keys(state.primaryData[0]);
                populateSelect(primaryColumnSelect, availableColumns);
                showElement(primaryColumnSelect);

                const handler = function() {
                  primaryColumnSelect.removeEventListener('change', handler);
                  hideElement(primaryColumnSelect);

                  const matchedColumn = primaryColumnSelect.value;
                  state.primaryColumn = matchedColumn;
                  writeToConsole(`You selected column: "${matchedColumn}"`, 'success');
                  resolve(true);
                };

                primaryColumnSelect.addEventListener('change', handler);
              });
            } else {
              // Threshold for single file via slider
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                thresholdRange.value = state.threshold;
                thresholdValue.textContent = parseFloat(state.threshold).toFixed(2);
                showElement(thresholdContainer);

                const updateVal = () => {
                  thresholdValue.textContent = parseFloat(thresholdRange.value).toFixed(2);
                };
                thresholdRange.addEventListener('input', updateVal);

                const handler = function() {
                  thresholdRange.removeEventListener('input', updateVal);
                  thresholdConfirmBtn.removeEventListener('click', handler);
                  hideElement(thresholdContainer);
                  state.threshold = parseFloat(thresholdRange.value);
                  writeToConsole(`Threshold set to: ${state.threshold}`, 'info');
                  resolve(true);
                };

                thresholdConfirmBtn.addEventListener('click', handler);
              });
            }
          }
        },
        {
          prompt: function() {
            return state.matchType === "twoFiles" ?
              "Which column from the secondary file should be matched against?" :
              "Which columns would you like to include in the results? (comma-separated, or 'all' for all columns)";
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                const availableColumns = Object.keys(state.secondaryData[0]);
                populateSelect(secondaryColumnSelect, availableColumns);
                showElement(secondaryColumnSelect);

                const handler = function() {
                  secondaryColumnSelect.removeEventListener('change', handler);
                  hideElement(secondaryColumnSelect);

                  const col = secondaryColumnSelect.value;
                  state.secondaryColumn = col;
                  writeToConsole(`You selected column: "${col}"`, 'success');
                  resolve(true);
                };

                secondaryColumnSelect.addEventListener('change', handler);
              });
            } else {
              // Return columns for single file via checkboxes
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                const availableColumns = Object.keys(state.primaryData[0]);
                populateCheckboxes(returnColumnsContainer, availableColumns);
                const btn = document.createElement('button');
                btn.textContent = 'Confirm Selection';
                btn.className = 'download-btn';
                btn.style.marginTop = '10px';
                returnColumnsContainer.appendChild(btn);
                showElement(returnColumnsContainer);

                const handler = function() {
                  btn.removeEventListener('click', handler);
                  hideElement(returnColumnsContainer);
                  const selected = getCheckedValues(returnColumnsContainer);
                  state.returnColumns = selected.length ? selected : availableColumns;
                  writeToConsole(`Selected columns: ${state.returnColumns.join(', ')}`, 'info');
                  resolve(true);
                };

                btn.addEventListener('click', handler);
              });
            }
          }
        },
        {
          prompt: function() {
            return state.matchType === "twoFiles" ?
              "Adjust the similarity threshold:" :
              null;
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                thresholdRange.value = state.threshold;
                thresholdValue.textContent = parseFloat(state.threshold).toFixed(2);
                showElement(thresholdContainer);

                const updateVal = () => {
                  thresholdValue.textContent = parseFloat(thresholdRange.value).toFixed(2);
                };
                thresholdRange.addEventListener('input', updateVal);

                const handler = function() {
                  thresholdRange.removeEventListener('input', updateVal);
                  thresholdConfirmBtn.removeEventListener('click', handler);
                  hideElement(thresholdContainer);
                  state.threshold = parseFloat(thresholdRange.value);
                  writeToConsole(`Threshold set to: ${state.threshold}`, 'info');
                  resolve(true);
                };

                thresholdConfirmBtn.addEventListener('click', handler);
              });
            }
            return true; // Skip for single file
          }
        },
        {
          prompt: function() {
            return state.matchType === "twoFiles" ?
              "Which columns from the secondary file would you like to include in the results? (comma-separated, or 'all' for all columns)" :
              null;
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                const availableColumns = Object.keys(state.secondaryData[0]);
                populateCheckboxes(returnColumnsContainer, availableColumns);
                const btn = document.createElement('button');
                btn.textContent = 'Confirm Selection';
                btn.className = 'download-btn';
                btn.style.marginTop = '10px';
                returnColumnsContainer.appendChild(btn);
                showElement(returnColumnsContainer);

                const handler = function() {
                  btn.removeEventListener('click', handler);
                  hideElement(returnColumnsContainer);
                  const selected = getCheckedValues(returnColumnsContainer);
                  state.returnColumns = selected.length ? selected : availableColumns;
                  writeToConsole(`Selected columns: ${state.returnColumns.join(', ')}`, 'info');
                  resolve(true);
                };

                btn.addEventListener('click', handler);
              });
            }
            return true; // Skip for single file
          }
        },
        {
          prompt: function() {
            return state.matchType === "twoFiles" ?
              "Choose how to output the results:" :
              null;
          },
          process: function(response) {
            if (state.matchType === "twoFiles") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                showElement(outputTypeContainer);

                const handler = function() {
                  outputTypeConfirmBtn.removeEventListener('click', handler);
                  hideElement(outputTypeContainer);
                  const selected = document.querySelector('input[name="outputType"]:checked').value;
                  state.outputType = selected;
                  if (selected === 'display') {
                    writeToConsole("Results will be displayed in the browser", 'info');
                  } else if (selected === 'csv') {
                    writeToConsole("Results will be downloaded as CSV", 'info');
                  } else {
                    writeToConsole("Results will be downloaded as Excel file", 'info');
                  }
                  resolve(true);
                };

                outputTypeConfirmBtn.addEventListener('click', handler);
              });
            }
            return true; // Skip for single file
          }
        },
        {
          prompt: function() {
            return state.matchType === "singleFile" ?
              "Choose how to output the results:" :
              null;
          },
          process: function(response) {
            if (state.matchType === "singleFile") {
              return new Promise((resolve) => {
                commandInput.disabled = true;
                submitButton.disabled = true;
                showElement(outputTypeContainer);

                const handler = function() {
                  outputTypeConfirmBtn.removeEventListener('click', handler);
                  hideElement(outputTypeContainer);
                  const selected = document.querySelector('input[name="outputType"]:checked').value;
                  state.outputType = selected;
                  if (selected === 'display') {
                    writeToConsole("Results will be displayed in the browser", 'info');
                  } else if (selected === 'csv') {
                    writeToConsole("Results will be downloaded as CSV", 'info');
                  } else {
                    writeToConsole("Results will be downloaded as Excel file", 'info');
                  }
                  resolve(true);
                };

                outputTypeConfirmBtn.addEventListener('click', handler);
              });
            }
            return true; // Skip for two files
          }
        },
        {
          prompt: "Processing your data... please wait",
          process: async function() {
            writeToConsole("Starting fuzzy matching process...", "info");
            showProgressBar();
            
            try {
              if (state.matchType === "twoFiles") {
                await performTwoFileMatch();
              } else {
                await performSingleFileMatch();
              }
              
              hideProgressBar();
              
              const totalMatches = state.matchResults.length;
              writeToConsole(`Completed! Found ${totalMatches} potential matches.`, "success");
              
              // Output the results
              if (state.outputType === "display") {
                displayResults();
              } else if (state.outputType === "csv") {
                downloadCsv();
              } else if (state.outputType === "excel") {
                downloadExcel();
              }
              
              return true;
            } catch (error) {
              hideProgressBar();
              writeToConsole(`Error during matching: ${error.message}`, "error");
              return false;
            }
          }
        }
      ]
    };

    // Utility Functions
    function writeToConsole(text, type = "command") {
      const element = document.createElement("div");
      element.className = type;
      element.textContent = text;
      console.appendChild(element);
      console.scrollTop = console.scrollHeight;
    }

    function promptUser(text) {
      const element = document.createElement("div");
      element.className = "prompt";
      element.textContent = "> " + text;
      console.appendChild(element);
      console.scrollTop = console.scrollHeight;

      // Enable input
      commandInput.disabled = false;
      submitButton.disabled = false;
      commandInput.focus();
    }

    function populateSelect(selectEl, options, placeholder = 'Select an option') {
      selectEl.innerHTML = '';

      const ph = document.createElement('option');
      ph.value = '';
      ph.textContent = placeholder;
      ph.disabled = true;
      ph.selected = true;
      selectEl.appendChild(ph);

      options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt;
        o.textContent = opt;
        selectEl.appendChild(o);
      });
    }

    function hideElement(el) { el.style.display = 'none'; }
    function showElement(el) { el.style.display = 'block'; }

    function populateCheckboxes(container, options) {
      container.innerHTML = '';
      options.forEach(opt => {
        const label = document.createElement('label');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = opt;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(' ' + opt));
        container.appendChild(label);
      });
    }

    function getCheckedValues(container) {
      return Array.from(container.querySelectorAll('input[type="checkbox"]:checked'))
              .map(cb => cb.value);
    }

    async function readFile(file, sheetName = null) {
      return new Promise((resolve, reject) => {
        const extension = file.name.split('.').pop().toLowerCase();
        
        if (extension === 'csv') {
          Papa.parse(file, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: (results) => {
              if (results.errors && results.errors.length > 0) {
                reject(new Error(results.errors[0].message));
              } else {
                resolve({
                  data: results.data,
                  isExcel: false,
                  sheetNames: null
                });
              }
            },
            error: (error) => {
              reject(error);
            }
          });
        } else if (['xlsx', 'xls'].includes(extension)) {
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = e.target.result;
              const workbook = XLSX.read(data, { type: 'array' });

              // Get all sheet names
              const sheetNames = workbook.SheetNames;

              if (!sheetNames || sheetNames.length === 0) {
                reject(new Error('Excel file contains no sheets'));
                return;
              }
              
              // If no specific sheet is requested, return the sheet names
              if (sheetName === null && sheetNames.length > 1) {
                resolve({
                  data: null,
                  isExcel: true,
                  sheetNames: sheetNames
                });
              } else {
                // Use the specified sheet or the first one
                const sheetToUse = sheetName || sheetNames[0];
                const worksheet = workbook.Sheets[sheetToUse];
                if (!worksheet) {
                  reject(new Error(`Sheet ${sheetToUse} not found`));
                  return;
                }
                const jsonData = XLSX.utils.sheet_to_json(worksheet);
                
                resolve({
                  data: jsonData,
                  isExcel: true,
                  sheetNames: sheetNames,
                  currentSheet: sheetToUse
                });
              }
            } catch (error) {
              reject(error);
            }
          };
          reader.onerror = (error) => {
            reject(error);
          };
          reader.readAsArrayBuffer(file);
        } else {
          reject(new Error("Unsupported file format"));
        }
      });
    }

    // Levenshtein distance for fuzzy matching
    function levenshteinDistance(a, b) {
      // Only treat null or undefined as missing values. Numeric zero is valid
      if (a === null || a === undefined || b === null || b === undefined) {
        return 0;
      }
      
      const aStr = String(a).toLowerCase();
      const bStr = String(b).toLowerCase();
      
      if (aStr === bStr) return 1.0; // Exact match
      if (aStr.length === 0 || bStr.length === 0) return 0.0;
      
      const matrix = Array(bStr.length + 1).fill().map(() => Array(aStr.length + 1).fill(0));
      
      // Initialize first row and column
      for (let i = 0; i <= aStr.length; i++) {
        matrix[0][i] = i;
      }
      
      for (let i = 0; i <= bStr.length; i++) {
        matrix[i][0] = i;
      }
      
      // Fill matrix
      for (let j = 1; j <= bStr.length; j++) {
        for (let i = 1; i <= aStr.length; i++) {
          const cost = aStr[i - 1] === bStr[j - 1] ? 0 : 1;
          matrix[j][i] = Math.min(
            matrix[j - 1][i] + 1,      // Deletion
            matrix[j][i - 1] + 1,      // Insertion
            matrix[j - 1][i - 1] + cost // Substitution
          );
        }
      }
      
      // Calculate similarity score (0-1 range)
      const maxLen = Math.max(aStr.length, bStr.length);
      if (maxLen === 0) return 1.0; // Both strings are empty
      
      return 1 - (matrix[bStr.length][aStr.length] / maxLen);
    }

    // Helper function to tokenize company names
function tokenizeCompanyName(name) {
  if (!name) return { mainTokens: [], suffixTokens: [], allTokens: [] };
  
  // Common suffixes that should have lower weight
  const commonSuffixes = [
    'games', 'studios', 'entertainment', 'llc', 'ltd', 'inc', 
    'corporation', 'corp', 'company', 'co', 'limited', 'digital',
    'interactive', 'software', 'productions', 'publishing'
  ];
  
  // Convert to lowercase and split into tokens
  const tokens = name.toLowerCase()
    .replace(/[^\w\s]/g, ' ') // Replace non-word chars with spaces
    .split(/\s+/)
    .filter(token => token.length > 0);
  
  // Separate main tokens from common suffixes
  const mainTokens = [];
  const suffixTokens = [];
  
  tokens.forEach(token => {
    if (commonSuffixes.includes(token)) {
      suffixTokens.push(token);
    } else {
      mainTokens.push(token);
    }
  });
  
  return { mainTokens, suffixTokens, allTokens: tokens };
}

// Helper function to tokenize company names
function tokenizeCompanyName(name) {
  if (!name) return { mainTokens: [], suffixTokens: [], allTokens: [] };
  
  // Common suffixes that should have lower weight
  const commonSuffixes = [
    'games', 'studios', 'entertainment', 'llc', 'ltd', 'inc', 
    'corporation', 'corp', 'company', 'co', 'limited', 'digital',
    'interactive', 'software', 'productions', 'publishing', 'intl',
    'international', 'usa', 'americas', 'domestic', 'consignment'
  ];
  
  // Convert to lowercase and split into tokens
  const tokens = name.toLowerCase()
    .replace(/[^\w\s&]/g, ' ') // Keep & symbol but remove other non-word chars
    .split(/\s+/)
    .filter(token => token.length > 0 && token !== '&');
  
  // Separate main tokens from common suffixes
  const mainTokens = [];
  const suffixTokens = [];
  
  tokens.forEach(token => {
    if (commonSuffixes.includes(token)) {
      suffixTokens.push(token);
    } else {
      mainTokens.push(token);
    }
  });
  
  return { mainTokens, suffixTokens, allTokens: tokens };
}

// Improved fuzzy matching function
function improvedFuzzyMatch(a, b) {
  if (!a || !b) return 0;
  
  // Exact match (case-insensitive)
  if (a.toLowerCase() === b.toLowerCase()) return 1.0;
  
  const tokensA = tokenizeCompanyName(a);
  const tokensB = tokenizeCompanyName(b);
  
  // If either has no main tokens, fall back to simple comparison
  if (tokensA.mainTokens.length === 0 || tokensB.mainTokens.length === 0) {
    return levenshteinDistance(a, b) * 0.5; // Penalize matches without main tokens
  }
  
  // Check for subset matches - if all main tokens from shorter name exist in longer name
  const shorterMainTokens = tokensA.mainTokens.length <= tokensB.mainTokens.length ? tokensA.mainTokens : tokensB.mainTokens;
  const longerMainTokens = tokensA.mainTokens.length > tokensB.mainTokens.length ? tokensA.mainTokens : tokensB.mainTokens;
  
  // Check if all shorter tokens are found in longer tokens
  let allShorterTokensFound = true;
  for (const token of shorterMainTokens) {
    if (!longerMainTokens.includes(token)) {
      // Also check for very similar tokens (like "boardgames" vs "boardgame")
      let foundSimilar = false;
      for (const longerToken of longerMainTokens) {
        if (levenshteinDistance(token, longerToken) > 0.85) {
          foundSimilar = true;
          break;
        }
      }
      if (!foundSimilar) {
        allShorterTokensFound = false;
        break;
      }
    }
  }
  
  // If all tokens from the shorter name are found in the longer name, it's likely the same company
  if (allShorterTokensFound && shorterMainTokens.length > 0) {
    // Give a high base score, with small penalty for extra words
    const extraWordsPenalty = Math.min(0.1, (longerMainTokens.length - shorterMainTokens.length) * 0.02);
    return Math.max(0.85, 0.95 - extraWordsPenalty);
  }
  
  // Also handle special cases for "&" separated names (like "TeeTurtle & Unstable Games")
  // Extract the first part before "&" if it exists
  const aBeforeAnd = a.split('&')[0].trim().toLowerCase();
  const bBeforeAnd = b.split('&')[0].trim().toLowerCase();
  
  if (aBeforeAnd && bBeforeAnd) {
    const tokensABeforeAnd = tokenizeCompanyName(aBeforeAnd);
    const tokensBBeforeAnd = tokenizeCompanyName(bBeforeAnd);
    
    // Check if the first part of one matches any part of the other
    if (tokensABeforeAnd.mainTokens.every(token => tokensB.mainTokens.includes(token)) ||
        tokensBBeforeAnd.mainTokens.every(token => tokensA.mainTokens.includes(token))) {
      return Math.max(0.85, 0.95 - Math.abs(tokensA.mainTokens.length - tokensB.mainTokens.length) * 0.02);
    }
  }
  
  // Calculate scores for different components
  let mainTokenScore = 0;
  let suffixScore = 0;
  let orderBonus = 0;
  
  // 1. Main token matching (most important)
  const mainMatches = new Set();
  tokensA.mainTokens.forEach(tokenA => {
    tokensB.mainTokens.forEach(tokenB => {
      if (tokenA === tokenB) {
        mainMatches.add(tokenA);
      } else {
        // Check for partial matches in main tokens
        const similarity = levenshteinDistance(tokenA, tokenB);
        if (similarity > 0.8) {
          mainTokenScore += similarity * 0.5;
        }
      }
    });
  });
  
  // Exact matches are worth more
  mainTokenScore += mainMatches.size;
  
  // Normalize main token score
  const maxMainTokens = Math.max(tokensA.mainTokens.length, tokensB.mainTokens.length);
  if (maxMainTokens > 0) {
    mainTokenScore = mainTokenScore / maxMainTokens;
  }
  
  // 2. Check if first main tokens match (company name usually starts with the most important word)
  if (tokensA.mainTokens[0] && tokensB.mainTokens[0]) {
    if (tokensA.mainTokens[0] === tokensB.mainTokens[0]) {
      orderBonus = 0.2;
    } else {
      const firstTokenSimilarity = levenshteinDistance(tokensA.mainTokens[0], tokensB.mainTokens[0]);
      if (firstTokenSimilarity > 0.8) {
        orderBonus = 0.1;
      }
    }
  }
  
  // 3. Suffix matching (less important)
  const suffixMatches = new Set();
  tokensA.suffixTokens.forEach(tokenA => {
    tokensB.suffixTokens.forEach(tokenB => {
      if (tokenA === tokenB) {
        suffixMatches.add(tokenA);
      }
    });
  });
  
  // Normalize suffix score
  const maxSuffixTokens = Math.max(tokensA.suffixTokens.length, tokensB.suffixTokens.length);
  if (maxSuffixTokens > 0) {
    suffixScore = suffixMatches.size / maxSuffixTokens;
  }
  
  // 4. Calculate weighted final score
  // Main tokens are 70% of score, order bonus is 20%, suffixes only 10%
  let finalScore = (mainTokenScore * 0.7) + (orderBonus) + (suffixScore * 0.1);
  
  // 5. Apply penalties for mismatches
  // If no main tokens match at all, cap the score
  if (mainMatches.size === 0 && mainTokenScore < 0.3) {
    finalScore = Math.min(finalScore, 0.3);
  }
  
  // If only suffixes match, cap the score even more
  if (mainMatches.size === 0 && suffixMatches.size > 0) {
    finalScore = Math.min(finalScore, 0.2);
  }
  
  return Math.min(finalScore, 1.0); // Ensure score doesn't exceed 1.0
}
    async function performTwoFileMatch() {
      const totalRows = state.primaryData.length;
      const batchSize = 10; // Process in batches to keep UI responsive
      let processedRows = 0;
      
      state.matchResults = [];
      
      for (let i = 0; i < totalRows; i += batchSize) {
        const batch = state.primaryData.slice(i, Math.min(i + batchSize, totalRows));
        
        await new Promise(resolve => {
          setTimeout(() => {
            batch.forEach(primaryRow => {
              const primaryValue = primaryRow[state.primaryColumn];
              
              state.secondaryData.forEach(secondaryRow => {
                const secondaryValue = secondaryRow[state.secondaryColumn];
                const similarityScore = improvedFuzzyMatch(primaryValue, secondaryValue);
                
                if (similarityScore >= state.threshold) {
                  const resultRow = {
                    primaryValue,
                    secondaryValue,
                    similarityScore
                  };
                  
                  // Add requested return columns
                  state.returnColumns.forEach(column => {
                    resultRow[column] = secondaryRow[column];
                  });
                  
                  state.matchResults.push(resultRow);
                }
              });
            });
            
            processedRows += batch.length;
            updateProgress(processedRows / totalRows * 100);
            resolve();
          }, 0);
        });
      }
      
      // Sort by similarity score (highest first)
      state.matchResults.sort((a, b) => b.similarityScore - a.similarityScore);
    }

    async function performSingleFileMatch() {
      const totalRows = state.primaryData.length;
      const batchSize = 10;
      let processedRows = 0;
      
      state.matchResults = [];
      
      for (let i = 0; i < totalRows; i += batchSize) {
        const batch = state.primaryData.slice(i, Math.min(i + batchSize, totalRows));
        
        await new Promise(resolve => {
          setTimeout(() => {
            batch.forEach((row1, idx1) => {
              const value1 = row1[state.primaryColumn];
              
              // Compare with all rows after this one to avoid duplicates
              for (let j = i + idx1 + 1; j < totalRows; j++) {
                const row2 = state.primaryData[j];
                const value2 = row2[state.primaryColumn];
                
                const similarityScore = improvedFuzzyMatch(value1, value2);
                
                if (similarityScore >= state.threshold && value1 !== value2) {
                  const resultRow = {
                    value1,
                    value2,
                    similarityScore,
                    row1Index: i + idx1,
                    row2Index: j
                  };
                  
                  // Add requested return columns
                  state.returnColumns.forEach(column => {
                    resultRow[`${column}_1`] = row1[column];
                    resultRow[`${column}_2`] = row2[column];
                  });
                  
                  state.matchResults.push(resultRow);
                }
              }
            });
            
            processedRows += batch.length;
            updateProgress(processedRows / totalRows * 100);
            resolve();
          }, 0);
        });
      }
      
      // Sort by similarity score (highest first)
      state.matchResults.sort((a, b) => b.similarityScore - a.similarityScore);
    }

    // Display the results in a table on the page
    function displayResults() {
      // Clear any previous results
      resultsContainer.innerHTML = '';

      // Create a table to display the results
      const resultsDiv = document.createElement("div");

      if (state.matchResults.length === 0) {
        resultsDiv.innerHTML = "<h2>No matches found with the current threshold.</h2>";
        resultsContainer.appendChild(resultsDiv);
        return;
      }
      
      // Create table
      const table = document.createElement("table");
      table.className = "result-table";
      
      // Create header row
      const thead = document.createElement("thead");
      const headerRow = document.createElement("tr");
      
      if (state.matchType === "twoFiles") {
        headerRow.innerHTML = `
          <th>Primary Value</th>
          <th>Secondary Value</th>
          <th>Similarity</th>
          ${state.returnColumns.map(col => `<th>${col}</th>`).join("")}
        `;
      } else {
        headerRow.innerHTML = `
          <th>Value 1</th>
          <th>Value 2</th>
          <th>Similarity</th>
          ${state.returnColumns.map(col => `<th>${col} (1)</th><th>${col} (2)</th>`).join("")}
        `;
      }
      
      thead.appendChild(headerRow);
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement("tbody");
      
      state.matchResults.slice(0, 1000).forEach(result => { // Limit to 1000 rows for browser display
        const row = document.createElement("tr");
        
        let scoreClass = "";
        if (result.similarityScore >= 0.9) {
          scoreClass = "score-high";
        } else if (result.similarityScore >= 0.8) {
          scoreClass = "score-medium";
        } else {
          scoreClass = "score-low";
        }
        
        if (state.matchType === "twoFiles") {
          row.innerHTML = `
            <td>${result.primaryValue}</td>
            <td>${result.secondaryValue}</td>
            <td class="${scoreClass}">${result.similarityScore.toFixed(3)}</td>
            ${state.returnColumns.map(col => `<td>${result[col] || ""}</td>`).join("")}
          `;
        } else {
          row.innerHTML = `
            <td>${result.value1}</td>
            <td>${result.value2}</td>
            <td class="${scoreClass}">${result.similarityScore.toFixed(3)}</td>
            ${state.returnColumns.map(col => 
              `<td>${result[`${col}_1`] || ""}</td><td>${result[`${col}_2`] || ""}</td>`
            ).join("")}
          `;
        }
        
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
      
      // Add table to the page
      resultsDiv.innerHTML = `<h2>Match Results (${state.matchResults.length} matches found)</h2>`;
      if (state.matchResults.length > 1000) {
        resultsDiv.innerHTML += `<p>Showing first 1000 matches. Download as CSV to see all results.</p>`;
      }
      resultsDiv.appendChild(table);
      
      // Create CSV for download
      let csvContent = "";
      
      // Create header row
      if (state.matchType === "twoFiles") {
        csvContent += `"Primary Value","Secondary Value","Similarity",${state.returnColumns.map(col => `"${col}"`).join(",")}\n`;
        
        // Add data rows
        state.matchResults.forEach(result => {
          csvContent += `"${result.primaryValue}","${result.secondaryValue}",${result.similarityScore.toFixed(5)},`;
          csvContent += state.returnColumns.map(col => {
            let value = result[col] || "";
            // Escape quotes in the value
            if (typeof value === "string") {
              value = value.replace(/"/g, '""');
            }
            return `"${value}"`;
          }).join(",");
          csvContent += "\n";
        });
      } else {
        csvContent += `"Value 1","Value 2","Similarity",`;
        csvContent += state.returnColumns.map(col => `"${col} (1)","${col} (2)"`).join(",") + "\n";
        
        // Add data rows
        state.matchResults.forEach(result => {
          csvContent += `"${result.value1}","${result.value2}",${result.similarityScore.toFixed(5)},`;
          csvContent += state.returnColumns.map(col => {
            let value1 = result[`${col}_1`] || "";
            let value2 = result[`${col}_2`] || "";
            // Escape quotes
            if (typeof value1 === "string") value1 = value1.replace(/"/g, '""');
            if (typeof value2 === "string") value2 = value2.replace(/"/g, '""');
            return `"${value1}","${value2}"`;
          }).join(",");
          csvContent += "\n";
        });
      }
      
      // Create a blob with the CSV data
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const blobUrl = URL.createObjectURL(blob);
      
      // Add a download button
      const downloadButton = document.createElement("button");
      downloadButton.textContent = "Download as CSV";
      downloadButton.onclick = function() {
        const link = document.createElement("a");
        link.href = blobUrl;
        link.download = "fuzzy_match_results.csv";
        link.click();
        writeToConsole("CSV file download initiated", "success");
      };
      downloadButton.style.marginTop = "20px";
      downloadButton.className = "download-btn";
      resultsDiv.appendChild(downloadButton);
      
      // Add an "Export to Excel" button
      const excelButton = document.createElement("button");
      excelButton.textContent = "Export to Excel";
      excelButton.style.marginLeft = "10px";
      excelButton.style.marginTop = "20px";
      excelButton.className = "download-btn";
      excelButton.onclick = function() {
        try {
          // Convert the CSV data to Excel
          const workbook = XLSX.utils.book_new();
          const worksheet = XLSX.utils.aoa_to_sheet([]);
          
          // Parse the CSV data
          Papa.parse(csvContent, {
            header: true,
            dynamicTyping: true,
            skipEmptyLines: true,
            complete: function(results) {
              // Add the data to the worksheet
              XLSX.utils.sheet_add_json(worksheet, results.data, { origin: "A1", skipHeader: false });
              XLSX.utils.book_append_sheet(workbook, worksheet, "Fuzzy Matches");
              
              // Save the file
              XLSX.writeFile(workbook, "fuzzy_match_results.xlsx");
              writeToConsole("Excel file download initiated", "success");
            }
          });
        } catch (error) {
          writeToConsole(`Error exporting to Excel: ${error.message}`, "error");
        }
      };
      resultsDiv.appendChild(excelButton);

      // Add rerun button to adjust threshold and reprocess
      const rerunButton = document.createElement("button");
      rerunButton.textContent = "Adjust Threshold & Re-run";
      rerunButton.className = "download-btn";
      rerunButton.style.marginLeft = "10px";
      rerunButton.onclick = adjustThresholdAndRerun;
      resultsDiv.appendChild(rerunButton);

      resultsContainer.appendChild(resultsDiv);
    }

    function downloadCsv() {
      if (state.matchResults.length === 0) {
        writeToConsole("No matches to download.", "error");
        return;
      }
      
      // Create a blob with the CSV data
      let csvContent = "";
      
      // Create header row
      if (state.matchType === "twoFiles") {
        csvContent += `"Primary Value","Secondary Value","Similarity",${state.returnColumns.map(col => `"${col}"`).join(",")}\n`;
        
        // Add data rows
        state.matchResults.forEach(result => {
          csvContent += `"${result.primaryValue}","${result.secondaryValue}",${result.similarityScore.toFixed(5)},`;
          csvContent += state.returnColumns.map(col => {
            let value = result[col] || "";
            // Escape quotes in the value
            if (typeof value === "string") {
              value = value.replace(/"/g, '""');
            }
            return `"${value}"`;
          }).join(",");
          csvContent += "\n";
        });
      } else {
        csvContent += `"Value 1","Value 2","Similarity",`;
        csvContent += state.returnColumns.map(col => `"${col} (1)","${col} (2)"`).join(",") + "\n";
        
        // Add data rows
        state.matchResults.forEach(result => {
          csvContent += `"${result.value1}","${result.value2}",${result.similarityScore.toFixed(5)},`;
          csvContent += state.returnColumns.map(col => {
            let value1 = result[`${col}_1`] || "";
            let value2 = result[`${col}_2`] || "";
            // Escape quotes
            if (typeof value1 === "string") value1 = value1.replace(/"/g, '""');
            if (typeof value2 === "string") value2 = value2.replace(/"/g, '""');
            return `"${value1}","${value2}"`;
          }).join(",");
          csvContent += "\n";
        });
      }
      
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const blobUrl = URL.createObjectURL(blob);
      
      // Create download link
      const link = document.createElement("a");
      link.setAttribute("href", blobUrl);
      link.setAttribute("download", "fuzzy_match_results.csv");
      link.style.display = "none";
      document.body.appendChild(link);
      
      // Try to trigger the download
      link.click();
      
      // Create visible download button as a fallback
      const downloadDiv = document.createElement("div");
      downloadDiv.style.marginTop = "20px";
      downloadDiv.style.padding = "15px";
      downloadDiv.style.backgroundColor = "#ffffff";
      downloadDiv.style.border = "1px solid #cccccc";
      downloadDiv.style.borderRadius = "5px";
      
      downloadDiv.innerHTML = `
        <p class="info">If the file didn't download automatically, click the button below:</p>
        <button id="manualDownloadBtn" class="download-btn">
          Download CSV Results
        </button>
        <p>Total Matches: ${state.matchResults.length}</p>
      `;
      
      resultsContainer.appendChild(downloadDiv);

      // Add rerun button to allow adjusting threshold
      const rerunBtn = document.createElement("button");
      rerunBtn.textContent = "Adjust Threshold & Re-run";
      rerunBtn.className = "download-btn";
      rerunBtn.style.marginLeft = "10px";
      rerunBtn.onclick = adjustThresholdAndRerun;
      downloadDiv.appendChild(rerunBtn);
      
      // Add event listener to the manual download button
      document.getElementById("manualDownloadBtn").addEventListener("click", function() {
        window.open(blobUrl, '_blank');
      });
      
      writeToConsole("CSV file prepared for download: fuzzy_match_results.csv", "success");
      writeToConsole("If download doesn't start automatically, use the manual download button below.", "info");
      
      // Clean up the hidden link element
      setTimeout(() => {
        document.body.removeChild(link);
      }, 100);
    }

    // Function to download results as Excel file
    function downloadExcel() {
      if (state.matchResults.length === 0) {
        writeToConsole("No matches to download.", "error");
        return;
      }
      
      try {
        writeToConsole("Preparing Excel file...", "info");
        
        // Create a new workbook
        const workbook = XLSX.utils.book_new();
        
        // Convert match results to an array format for Excel
        const excelData = [];
        
        // Add header row
        if (state.matchType === "twoFiles") {
          const headerRow = ["Primary Value", "Secondary Value", "Similarity"];
          state.returnColumns.forEach(col => headerRow.push(col));
          excelData.push(headerRow);
          
          // Add data rows
          state.matchResults.forEach(result => {
            const row = [
              result.primaryValue,
              result.secondaryValue,
              result.similarityScore
            ];
            
            state.returnColumns.forEach(col => {
              row.push(result[col] || "");
            });
            
            excelData.push(row);
          });
        } else {
          // For single file duplicates
          const headerRow = ["Value 1", "Value 2", "Similarity"];
          state.returnColumns.forEach(col => {
            headerRow.push(`${col} (1)`);
            headerRow.push(`${col} (2)`);
          });
          excelData.push(headerRow);
          
          // Add data rows
          state.matchResults.forEach(result => {
            const row = [
              result.value1,
              result.value2,
              result.similarityScore
            ];
            
            state.returnColumns.forEach(col => {
              row.push(result[`${col}_1`] || "");
              row.push(result[`${col}_2`] || "");
            });
            
            excelData.push(row);
          });
        }
        
        // Create worksheet
        const worksheet = XLSX.utils.aoa_to_sheet(excelData);
        
        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(workbook, worksheet, "Fuzzy Matches");
        
        // Apply basic formatting
        const colWidth = [];
        excelData[0].forEach(() => colWidth.push({ wch: 15 })); // Set column width
        worksheet['!cols'] = colWidth;
        
        // Save the file
        XLSX.writeFile(workbook, "fuzzy_match_results.xlsx");
        
        writeToConsole("Excel file download initiated: fuzzy_match_results.xlsx", "success");
        
        // Create visible download button as a fallback
        const downloadDiv = document.createElement("div");
        downloadDiv.style.marginTop = "20px";
        downloadDiv.style.padding = "15px";
        downloadDiv.style.backgroundColor = "#ffffff";
        downloadDiv.style.border = "1px solid #cccccc";
        downloadDiv.style.borderRadius = "5px";
        
        downloadDiv.innerHTML = `
          <p class="info">If the Excel file didn't download automatically:</p>
          <p>1. Try the buttons below, or</p>
          <p>2. Use the CSV download option instead:</p>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="manualExcelBtn" class="download-btn">
              Try Excel Download Again
            </button>
            <button id="manualCsvBtn" class="fallback-btn">
              Download as CSV Instead
            </button>
          </div>
          <p>Total Matches: ${state.matchResults.length}</p>
        `;
        
        resultsContainer.appendChild(downloadDiv);

        // Add rerun button to adjust threshold and reprocess
        const rerunBtn = document.createElement("button");
        rerunBtn.textContent = "Adjust Threshold & Re-run";
        rerunBtn.className = "download-btn";
        rerunBtn.style.marginLeft = "10px";
        rerunBtn.onclick = adjustThresholdAndRerun;
        downloadDiv.appendChild(rerunBtn);
        
        // Add event listeners to the manual download buttons
        document.getElementById("manualExcelBtn").addEventListener("click", function() {
          // Try the Excel download again
          XLSX.writeFile(workbook, "fuzzy_match_results.xlsx");
        });
        
        document.getElementById("manualCsvBtn").addEventListener("click", function() {
          // Switch to CSV download
          downloadCsv();
        });
        
      } catch (error) {
        writeToConsole(`Error creating Excel file: ${error.message}`, "error");
        writeToConsole("Trying CSV download as fallback...", "info");
        // Fall back to CSV if Excel export fails
        downloadCsv();
      }
    }

    // Allow user to adjust the threshold and re-run matching without
    // reselecting input files
    async function adjustThresholdAndRerun() {
      thresholdRange.value = state.threshold;
      thresholdValue.textContent = parseFloat(state.threshold).toFixed(2);
      showElement(thresholdContainer);

      const updateVal = () => {
        thresholdValue.textContent = parseFloat(thresholdRange.value).toFixed(2);
      };
      thresholdRange.addEventListener('input', updateVal);

      const handler = async function() {
        thresholdRange.removeEventListener('input', updateVal);
        thresholdConfirmBtn.removeEventListener('click', handler);
        hideElement(thresholdContainer);

        state.threshold = parseFloat(thresholdRange.value);
        writeToConsole(`Threshold set to: ${state.threshold}`, 'info');
        writeToConsole('Re-running match with new threshold...', 'info');

        showProgressBar();
        if (state.matchType === 'twoFiles') {
          await performTwoFileMatch();
        } else {
          await performSingleFileMatch();
        }
        hideProgressBar();

        const totalMatches = state.matchResults.length;
        writeToConsole(`Re-run complete! Found ${totalMatches} potential matches.`, 'success');

        resultsContainer.innerHTML = '';
        if (state.outputType === 'display') {
          displayResults();
        } else if (state.outputType === 'csv') {
          downloadCsv();
        } else if (state.outputType === 'excel') {
          downloadExcel();
        }
      };

      thresholdConfirmBtn.addEventListener('click', handler);
    }

    function showProgressBar() {
      progressBar.style.display = "block";
      progressBarFill.style.width = "0%";
      progressBar.setAttribute('aria-valuenow', '0');
    }

    function updateProgress(percentage) {
      progressBarFill.style.width = percentage + "%";
      progressBar.setAttribute('aria-valuenow', Math.round(percentage).toString());
    }

    function hideProgressBar() {
      progressBar.style.display = "none";
    }

    function startWorkflow(workflowName) {
      state = {
        workflow: workflowName,
        step: 0,
        primaryFile: null,
        secondaryFile: null,
        primaryData: null,
        secondaryData: null,
        primarySheetNames: null,
        secondarySheetNames: null,
        primarySelectedSheet: null,
        secondarySelectedSheet: null,
        primaryColumn: null,
        secondaryColumn: null,
        returnColumns: [],
        threshold: 0.7,
        matchResults: [],
        outputType: null
      };
      
      // Reset file inputs
      primaryFileInput.value = "";
      secondaryFileInput.value = "";
      primaryFileName.textContent = "No file chosen";
      secondaryFileName.textContent = "No file chosen";

      // Clear previous results
      resultsContainer.innerHTML = '';

      processCurrentStep();
    }

    async function processCurrentStep() {
      const workflow = workflows[state.workflow];
      
      if (state.step >= workflow.length) {
        // Workflow complete
        writeToConsole("Process complete!", "success");
        commandInput.disabled = true;
        submitButton.disabled = true;
        executeButton.disabled = false;
        return;
      }
      
      const step = workflow[state.step];
      
      // If prompt is a function, execute it to get the prompt text
      const promptText = typeof step.prompt === 'function' ? step.prompt() : step.prompt;
      
      if (promptText === null) {
        // Skip this step
        state.step++;
        processCurrentStep();
        return;
      }
      
      executeButton.disabled = true;
      promptUser(promptText);
      
      // Check if this step involves file selection or automatic processing
      const isFileStep = typeof step.process === 'function' && (
        step.process.toString().includes('addEventListener')
      );
      
      const isAutoProcessStep = typeof step.process === 'function' && (
        step.process.toString().includes('performTwoFileMatch') ||
        step.process.toString().includes('performSingleFileMatch')
      );
      
      // If this step doesn't need user input, process it immediately
      if (isFileStep || isAutoProcessStep) {
        commandInput.disabled = true;
        submitButton.disabled = true;
        
        try {
          writeToConsole("Processing step...", "info");
          const result = await step.process();
          
          if (result) {
            state.step++;
            // Small delay to ensure UI updates properly
            setTimeout(() => {
              processCurrentStep();
            }, 100);
          } else {
            commandInput.disabled = false;
            submitButton.disabled = false;
          }
        } catch (error) {
          writeToConsole(`Error: ${error.message}`, "error");
          commandInput.disabled = false;
          submitButton.disabled = false;
        }
      }
    }

    // Event handlers
    executeButton.addEventListener("click", function() {
      console.innerHTML = '';
      startWorkflow("fuzzyMatch");
    });

    clearButton.addEventListener("click", function() {
      console.innerHTML = '';
    });

    submitButton.addEventListener("click", async function() {
      const response = commandInput.value.trim();
      writeToConsole(response);
      
      commandInput.value = "";
      commandInput.disabled = true;
      submitButton.disabled = true;
      
      const workflow = workflows[state.workflow];
      const step = workflow[state.step];
      
      try {
        const result = await step.process(response);
        if (result) {
          state.step++;
          processCurrentStep();
        } else {
          commandInput.disabled = false;
          submitButton.disabled = false;
          commandInput.focus();
        }
      } catch (error) {
        writeToConsole(`Error: ${error.message}`, "error");
        commandInput.disabled = false;
        submitButton.disabled = false;
        commandInput.focus();
      }
    });

    commandInput.addEventListener("keyup", function(event) {
      if (event.key === "Enter") {
        submitButton.click();
      }
    });
  </script>
</body>
</html>
